Everything I discuss is going to be in the context of https://github.com/danielpmcconkey/PersonalFinance . It's a very
large solution. Solution is .net speak for multiple executables and library projects that are part of the same domain. 
In this case, I have 5 separate projects all focused on my personal finance and retirement planning. 
https://github.com/danielpmcconkey/PersonalFinance/blob/main/Lib/AgentContext.txt is a context file I feed into AI at 
the beginning of every session to tell it what is important about the overall solution and it's not a bad place to start
if you actually want to understand the code. That should be optional unless you really want to geek-out here.

##Example 1: moving nudge-mode from a global config setting to something that can be selected for each call

I had previously (in version 0.10.0) added a static config value to the MonteCarloConfig file 
https://github.com/danielpmcconkey/PersonalFinance/blob/0f52fcaba4cd6fa2e0ab5077324102a9bcc6ee8a/Lib/StaticConfig/MonteCarloConfig.cs

```C#
   /// <summary>
   /// When enabled, the model breeder will be way less drastic in its randomization
   /// </summary>
   public static bool IsNudgeModeOn;
\```
It could be set in the appsettings.json 
https://github.com/danielpmcconkey/PersonalFinance/blob/0f52fcaba4cd6fa2e0ab5077324102a9bcc6ee8a/ModelTrainer/appsettings.json
And it was used in the Model.cs class's "mating" methods. This uses an evolutionary algorithm to allow the most 
successful models to combine their characteristics into the next generation. Previously, everything Model property was 
either exactly inherited from parent A, exactly inherited from parent B, or a completely random value within the min and
max for that property. Nudge mode forced the random value to be way less random and much closer to the parent values. 

You can see this in action in lines 50 to 62:

```C#
     T candidate;
     switch (GetHereditarySource())
     {
       case HereditarySource.ParentA:
         candidate = propertySelector(parentA);
         break;
       case HereditarySource.ParentB:
         candidate = propertySelector(parentB);
         break;
       default:
         if(MonteCarloConfig.IsNudgeModeOn) candidate = GenerateNudgeValue(
           minValue, maxValue, propertySelector(parentA), propertySelector(parentB));
         else candidate = MathFunc.GenerateRandomBetween(minValue, maxValue);
         break;
     }
\```
I decided I didn't like this "only one way the other" method. (I'm now sharing code from version (0.17.0.) I wanted each
time I called MateModels (line 200) for the code to "flip a coin" on whether to use nudge mode. I asked the AI first to
generate a flip a coin method. Easy enough. It did that and I put it in
https://github.com/danielpmcconkey/PersonalFinance/blob/main/Lib/Utils/MathFunc.cs

```C#
   public static CoinFlip FlipACoin()
   {
     return Random.Next(2) == 0 ? CoinFlip.Heads : CoinFlip.Tails;
   }
\```

Interestingly, it pointed out that some of my other random number generators were less efficient and made a
recommendation that I took. My GetUnSeededRandomX methods were all generating a new instance of .net's Random class
(https://learn.microsoft.com/en-us/dotnet/api/system.random?view=net-9.0) and suggested I make a static instance and
just call Random.next. That was cool. Then I asked it to do what I really wanted it to do. I told it I wanted it to make
the model mating function use the coin flip to determine whether to use nudge mode.

I gave me a good solution, 
(https://github.com/danielpmcconkey/PersonalFinance/blob/main/Lib/MonteCarlo/StaticFunctions/ModelFunc.cs) but I didn't
ask it the right thing. I neglected to tell it that I no longer wanted a global config value. So it kept the IsNudgeMode
global config and set the model mating methods to override it when necessary. MateNumericProperty() still used the
switch to call either GenerateNudgeValue() or GenerateRandomBetween(), but it now took a nudgeMode boolean as an
argument. That method gets called about 20 times in the MateModels() function (line 206) and you can see it calls the
coin flip in line 210 and uses the result a bunch of times later down. I didn't type that. AI did.

I had to write some new unit tests. I tried that with AI, but they were too complicated for it. I ended up writing
MateModels_WithIdenticalParentsAndManyRuns_ShowsCorrectStatisticalVariation myself.
https://github.com/danielpmcconkey/PersonalFinance/blob/main/Lib.Tests/MonteCarlo/StaticFunctions/ModelFuncTests.cs#L669

##Example 2: finding and fixing a bug in model clean-up

Back in 0.16.0 (probably earlier), I had a clean-up method called CleanUpModelAndRunResultsData in SimulationTrigger.cs
https://github.com/danielpmcconkey/PersonalFinance/blob/b1a42e4dd182c9e3674357c29e5e8f38b2865216/Lib/MonteCarlo/StaticFunctions/SimulationTrigger.cs
. This method was a mess, but it worked (or so I thought). It sends some raw SQL to my PostgreSQL database to determine
any models that have no living descendants. Then it attempts to delete those models and finally an run result data
associated to those child-less models. A mistake I made a long time ago was not setting up a key constraint between
these tables, but that's a different story.

Anyhow, I thought this was working fine. I didn't have a giant build-up of models in my DB and I never bothered to 
actually scrutinize this function very well. But then came recent days when I wanted to exclude certain models from the
purge. I have the need to declare certain models as the best of their generation and use them for my to drive some of 
the apps in this same solution. 

So I asked Claude to give me SQL to create a new "modelchampions" database table, to create a ModelChampion data type,
to update my ORM definition, and to finally exclude any model I put in the modelchampions table from the purge. 

1. It created the SQL perfectly, and even anticipated that I'd want a "notes" column I didn't ask for but decided to
keep.  
2. It created the ModelChampion class fine. It made the change to the ORM (here's the v0.19.0 version
https://github.com/danielpmcconkey/PersonalFinance/blob/main/Lib/DataTypes/MonteCarlo/ModelChampion.cs)
3. It made the change to the ORM definition just fine (lines 30 and 237 - 244 of 
https://github.com/danielpmcconkey/PersonalFinance/blob/main/Lib/PgContext.cs)

The interesting part is with the change to that old SQL-driven function in
https://github.com/danielpmcconkey/PersonalFinance/blob/b1a42e4dd182c9e3674357c29e5e8f38b2865216/Lib/MonteCarlo/StaticFunctions/SimulationTrigger.cs
It told me that I had an error in it. I actually have multiple errors. It found one, but it got me to really think about
this method. The error it found was that the way my SQL to find the childless models is formed. I had a group by with a
having statement that looked for count in the child tables of 0. This using an aggregate to detect nulls isn't right. It
told me to use not exists and that turned out to catch a bunch more childless models. I'm still not certain why my
old SQL worked most of the time. But AI was definitely right.

The next thing is that I realized that my logic was all stupid. The first section of that method finds all the childless
models and deletes them. The second part tries to delete all the run results of my childless models, but re-checks which
models are childless. Since I'd just deleted them, the part that deletes run results would never delete anything.

AI didn't catch this bug, but I was so proud of myself that I told AI what I'd discovered. It agreed with me. 

As a side, I decided that I wanted to get rid of the sloppy raw SQL. Version 0.19.0 
https://github.com/danielpmcconkey/PersonalFinance/blob/main/Lib/MonteCarlo/StaticFunctions/SimulationTrigger.cs shows 
a modernized version of CleanUpModelAndRunResultsData (line 175). It uses Linq to SQL (part of Microsoft's Entity 
Framework ORM) to do this much more elegantly. AI helped me with that change too.
